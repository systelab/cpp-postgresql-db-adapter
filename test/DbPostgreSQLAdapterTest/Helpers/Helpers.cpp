#include "stdafx.h"
#include "Helpers.h"

#include "Connection.h"
#include "ConnectionConfiguration.h"
#include "DbAdapterInterface/IDatabase.h"
#include "DbAdapterInterface/ITransaction.h"
#include "DefaultConnectionConfiguration.h"
#include "PostgresUtils.h"

using namespace std::chrono_literals;
namespace systelab::db::postgresql::unit_test {
	
	std::string getPrefixedElement(const std::string& elementName, const std::string& prefix)
	{
		return prefix + ".\"" + elementName + '"';
	}

	void createTable(IDatabase& db, const std::string& tableName, const std::string& prefix, const unsigned int numRecords)
	{
		const std::string prefixedTable = getPrefixedElement(tableName, prefix);

		db.executeOperation( "CREATE TABLE " + prefixedTable + " " +
							 "(ID INT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY, " +
							 " FIELD_INT_INDEX INT, "+
							 " FIELD_INT_NO_INDEX INT DEFAULT 2, " +
							 " FIELD_STR_INDEX TEXT, " +
							 " FIELD_STR_NO_INDEX TEXT DEFAULT 'FIELD_STR_NO_INDEX', " +
							 " FIELD_REAL REAL DEFAULT 3.3, " +
							 " FIELD_BOOL BOOLEAN DEFAULT False, " +
							 " FIELD_DATE TIMESTAMP WITH TIME ZONE DEFAULT '20160102T030405') " );

		db.executeOperation( "CREATE INDEX \"INT_INDEX_" + tableName + "\" ON " + prefixedTable + "(FIELD_INT_INDEX)" );
		db.executeOperation( "CREATE INDEX \"STR_INDEX_" + tableName+ "\" ON " + prefixedTable + "(FIELD_STR_INDEX)" );

		std::unique_ptr<ITransaction> transaction = db.startTransaction();

		for (unsigned int i = 0; i < numRecords; i++)
		{
			std::ostringstream oss;
			oss << "INSERT INTO " << prefixedTable << " "
				<< "(FIELD_INT_INDEX, FIELD_INT_NO_INDEX, "
				<< " FIELD_STR_INDEX, FIELD_STR_NO_INDEX, "
				<< " FIELD_REAL, FIELD_BOOL, "
				<< " FIELD_DATE ) "
				<< "VALUES "
				<< "( " << getFieldIntIndexValue(i)
				<< ", " << getFieldIntNoIndexValue(i)
				<< ", " << "'" << getFieldStringIndexValue(i) << "'"
				<< ", " << "'" << getFieldStringNoIndexValue(i) << "'"
				<< ", " << getFieldRealValue(i)
				<< ", " << (getFieldBooleanValue(i) ? "True" : "False")
				<< ", " << "'" << utils::dateTimeToISOString(getFieldDateValue(i)) << "'"
				<< " ) RETURNING ID";

			db.executeOperation(oss.str());
			RowsAffected nRows = db.getRowsAffectedByLastChangeOperation();
			ASSERT_EQ(nRows, 1);
		}

		transaction->commit();
		transaction.reset();
	}

	void createPairOfTables(IDatabase& db,
							const std::string& tableName_t1, const unsigned int numRecords_t1,
							const std::string& tableName_t2, const unsigned int numRecords_t2,
							const std::string& onDelete, const std::string& onUpdate)
	{
		db.executeOperation("CREATE TABLE "+tableName_t1+"(ID INT PRIMARY KEY NOT NULL, FIELD_INT INT, FIELD_STR VARCHAR(255))");
		db.executeOperation("CREATE TABLE "+tableName_t2+"(ID INT, FIELD_INT_REF_T1 INT, FIELD_INT INT, FIELD_STR VARCHAR(255), FOREIGN KEY(FIELD_INT_REF_T1) REFERENCES " + tableName_t1 + 
							"(ID) ON DELETE " + onDelete + " ON UPDATE " + onUpdate + ")");
		
		std::unique_ptr<ITransaction> transaction = db.startTransaction();
		for (unsigned int i = 0; i < numRecords_t1; i++)
		{
			std::ostringstream oss;
		
			oss << "INSERT INTO "+tableName_t1+" (ID, FIELD_INT, FIELD_STR) VALUES (" 
				<< i 
				<< ", " << i%4 
				<< ", \'STR" << i % 9 << '\''
				<< ") RETURNING ID";
			db.executeOperation(oss.str());
		}

		for (unsigned int i = 0; i < numRecords_t2; i++)
		{
			std::ostringstream oss;
		
			oss << "INSERT INTO "+tableName_t2+" (ID, FIELD_INT_REF_T1, FIELD_INT, FIELD_STR) VALUES (" 
				<< i 
				<< ", " << i%4 
				<< ", " << i%20
				<< ", \'STR" << i % 9 << '\''
				<< ") RETURNING ID";
			db.executeOperation(oss.str());
		}

		transaction->commit();
		transaction.reset();
	}

	void dropTable(IDatabase& db, const std::string table)
	{
		db.executeOperation("DROP TABLE IF EXISTS " + table);
	}

	void createDatabase(const std::string& dbName)
	{
		const std::string postgressdbName = "postgres";
		auto connectionConfiguration = ConnectionConfiguration(defaultDbUser, defaultDbPassword, defaultDbHost, defaultDbPort, postgressdbName);
		const auto m_db = Connection().loadDatabase(connectionConfiguration);

		m_db->executeOperation("CREATE DATABASE \"" + dbName + '\"');
	}

	void dropDatabase(const std::string& dbName)
	{
		const std::string postgressdbName = "postgres";
		auto connectionConfiguration = ConnectionConfiguration(defaultDbUser, defaultDbPassword, defaultDbHost, defaultDbPort, postgressdbName);
		const auto m_db = Connection().loadDatabase(connectionConfiguration);

		m_db->executeOperation("DROP DATABASE IF EXISTS \"" + dbName + '\"');
	}

	int getFieldIntIndexValue(unsigned int id)
	{
		return id % 7;
	}

	int getFieldIntNoIndexValue(unsigned int id)
	{
		return id % 10;
	}

	std::string getFieldStringIndexValue(unsigned int id)
	{
		std::ostringstream oss;
		oss << "STR" << id % 9;
		return oss.str();
	}

	std::string getFieldStringNoIndexValue(unsigned int id)
	{
		std::ostringstream oss; 
		oss << "STR" << id % 12;
		return oss.str();
	}

	double getFieldRealValue(unsigned int id)
	{
		return (id % 13) / 10.;
	}

	bool getFieldBooleanValue(unsigned int id)
	{
		return (id % 2 == 0);
	}

	std::chrono::system_clock::time_point getFieldDateValue(unsigned int id)
	{
		return getFieldDateBaseDate() + std::chrono::days{id % 7};
	}

	std::chrono::system_clock::time_point getFieldDateBaseDate()
	{
		return std::chrono::system_clock::time_point{ std::chrono::sys_days{12d / 2 / 2024} };
	}

	unsigned int getNumRecordsWithFieldIntIndexZero(unsigned int tableRecords)
	{
		return static_cast<unsigned int>(ceil (tableRecords / 7.));
	}

	unsigned int getNumRecordsWithFieldIntNoIndexZero(unsigned int tableRecords)
	{
		return static_cast<unsigned int>(ceil (tableRecords / 10.));
	}

	unsigned int getNumRecordsWithFieldStringIndexZero(unsigned int tableRecords)
	{
		return static_cast<unsigned int>(ceil (tableRecords / 9.));
	}

	unsigned int getNumRecordsWithFieldStringNoIndexZero(unsigned int tableRecords)
	{
		return static_cast<unsigned int>(ceil (tableRecords / 12.));
	}

	unsigned int getNumRecordsWithFieldRealZero(unsigned int tableRecords)
	{
		return static_cast<unsigned int>(ceil (tableRecords / 13.));
	}

	unsigned int getNumRecordsWithFieldBoolTrue(unsigned int tableRecords)
	{
		return static_cast<unsigned int>(ceil (tableRecords / 2.));
	}

	unsigned int getNumRecordsWithFieldDateIsBaseDate(unsigned int tableRecords)
	{
		return static_cast<unsigned int>(ceil (tableRecords / 7.));
	}

}
